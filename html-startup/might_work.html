<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Cypher Messages</title>
  <style>
    body {
      margin: 0;
      height: 100vh;
      display: flex;
      font-family: Arial, sans-serif;
      background: #f4f6f8;
    }
    /* Sidebar */
    .sidebar {
      width: 250px;
      background: #222;
      color: #fff;
      display: flex;
      flex-direction: column;
      padding: 1rem;
    }
    .sidebar h2 {
      font-size: 1.3rem;
      margin-bottom: 1rem;
    }
    .new-message-btn {
      background: #444;
      color: #fff;
      border: none;
      padding: 0.75rem;
      border-radius: 8px;
      margin-bottom: 1rem;
      cursor: pointer;
      transition: background 0.2s;
    }
    .new-message-btn:hover {
      background: #666;
    }
    .conversation-list {
      flex: 1;
      overflow-y: auto;
    }
    .conversation-btn {
      width: 100%;
      background: #333;
      color: #fff;
      border: none;
      padding: 0.8rem;
      margin: 0.3rem 0;
      border-radius: 6px;
      text-align: left;
      cursor: pointer;
      transition: background 0.2s;
    }
    .conversation-btn:hover {
      background: #555;
    }

    /* Main chat area */
    .chat-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 1rem;
    }
    .chat-header {
      background: #fff;
      padding: 1rem;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      margin-bottom: 1rem;
    }
    .chat-window {
      flex: 1;
      background: #fff;
      border-radius: 8px;
      padding: 1rem;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      overflow-y: auto;
    }
    .message {
      margin: 0.5rem 0;
      padding: 0.6rem 0.9rem;
      border-radius: 8px;
      max-width: 70%;
    }
    .message.sent {
      background: #222;
      color: #fff;
      margin-left: auto;
    }
    .message.received {
      background: #eee;
      color: #222;
      margin-right: auto;
    }
  </style>
</head>
<body>
  <!-- Sidebar -->
  <div class="sidebar">
    <h2>Messages</h2>
    <button class="new-message-btn">+ New Message</button>
    <div class="conversation-list">
      <button class="conversation-btn">Alice</button>
      <button class="conversation-btn">Bob</button>
      <button class="conversation-btn">Charlie</button>
    </div>
  </div>

  <!-- Chat area -->
  <div class="chat-area">
    <div class="chat-header">
      <h3>Conversation with Alice</h3>
    </div>
    <div class="chat-window">
      <div class="message received">Hey there! How are you?</div>
      <div class="message sent">Iâ€™m good, thanks! How about you?</div>
      <div class="message received">Doing well, excited for this project!</div>
    </div>
  </div>
    <script>
  // ============================================================
  // ALPHABET MAPS
  // ============================================================
  const alphabetMap = {
    ...Object.fromEntries(Array.from({length:26}, (_, i) => [String.fromCharCode(97+i), i])),        // a-z
    ...Object.fromEntries(Array.from({length:26}, (_, i) => [String.fromCharCode(65+i), 26 + i])),   // A-Z
    ...Object.fromEntries(Array.from({length:10}, (_, i) => [String(i), 52 + i])),                   // 0-9
    " ": 62, ".": 63, ",": 64, "!": 65, "?": 66,
    "'": 67, "\"": 68, ":": 69, ";": 70, "-": 71,
    "(": 72, ")": 73
  };
  const reverseMap = Object.fromEntries(Object.entries(alphabetMap).map(([k,v]) => [v,k]));

  function textToNumbers(s){ return [...s].map(c=>alphabetMap[c]).filter(v=>v!==undefined); }
  function numbersToText(nums){ return nums.map(n => reverseMap[n]||"").join(""); }

  // ============================================================
  // OTP FUNCTIONS
  // ============================================================
  function generateOtp(length){
    const otp = new Uint8Array(length);
    crypto.getRandomValues(otp);
    return Array.from(otp, b => b % Object.keys(alphabetMap).length);
  }
  function otpEncrypt(numbers,key){
    const L = Object.keys(alphabetMap).length;
    return numbers.map((n,i)=> (n + key[i]) % L);
  }
  function otpDecrypt(numbers,key){
    const L = Object.keys(alphabetMap).length;
    return numbers.map((c,i)=> (c - key[i] + L) % L);
  }

  // ============================================================
  // RSA KEY MANAGEMENT
  // ============================================================
  async function generateRSAKeys(){
    return await crypto.subtle.generateKey(
      { name:"RSA-OAEP", modulusLength:2048, publicExponent:new Uint8Array([1,0,1]), hash:"SHA-256" },
      true,
      ["encrypt","decrypt"]
    );
  }
  async function exportKey(key){
    const exported = await crypto.subtle.exportKey("spki", key);
    return btoa(String.fromCharCode(...new Uint8Array(exported)));
  }
  async function importPublicKey(base64Key){
    const binary = Uint8Array.from(atob(base64Key), c=>c.charCodeAt(0));
    return await crypto.subtle.importKey("spki", binary.buffer, {name:"RSA-OAEP", hash:"SHA-256"}, true, ["encrypt"]);
  }

  // ============================================================
  // HMAC
  // ============================================================
  async function generateHmac(keyBytes,messageBytes){
    const cryptoKey = await crypto.subtle.importKey(
      "raw", new Uint8Array(keyBytes), {name:"HMAC", hash:"SHA-256"}, false, ["sign"]
    );
    const sig = await crypto.subtle.sign("HMAC", cryptoKey, new Uint8Array(messageBytes));
    return Array.from(new Uint8Array(sig)).map(b=>b.toString(16).padStart(2,"0")).join("");
  }

  // ============================================================
  // HYBRID ENCRYPT / DECRYPT
  // ============================================================
  async function hybridEncrypt(message, publicKey){
    const msgNumbers = textToNumbers(message);
    const otpKey = generateOtp(msgNumbers.length);
    const encryptedMessage = otpEncrypt(msgNumbers, otpKey);

    const encryptedOtpKey = await Promise.all(
      otpKey.map(async k => {
        const enc = await crypto.subtle.encrypt({name:"RSA-OAEP"}, publicKey, new Uint8Array([k]));
        return btoa(String.fromCharCode(...new Uint8Array(enc)));
      })
    );

    const mac = await generateHmac(otpKey, encryptedMessage);
    return { encrypted_message: encryptedMessage, encrypted_otp_key: encryptedOtpKey, hmac: mac };
  }

  async function hybridDecrypt(pkg, privateKey){
    const otpKey = await Promise.all(
      pkg.encrypted_otp_key.map(async encStr => {
        const binary = Uint8Array.from(atob(encStr), c=>c.charCodeAt(0));
        const dec = await crypto.subtle.decrypt({name:"RSA-OAEP"}, privateKey, binary.buffer);
        const arr = new Uint8Array(dec);
        return arr[arr.length - 1]; // last byte holds the key value
      })
    );

    const macCheck = await generateHmac(otpKey, pkg.encrypted_message);
    if(macCheck !== pkg.hmac) throw new Error("Message integrity check failed!");

    const decryptedNumbers = otpDecrypt(pkg.encrypted_message, otpKey);
    return numbersToText(decryptedNumbers);
  }

  // ============================================================
  // PASSWORD-PROTECTED PRIVATE KEY STORAGE
  // ============================================================
  async function deriveKeyFromPassword(password,salt){
    const enc = new TextEncoder();
    const keyMaterial = await crypto.subtle.importKey("raw", enc.encode(password), "PBKDF2", false, ["deriveKey"]);
    return crypto.subtle.deriveKey({name:"PBKDF2", salt, iterations:100000, hash:"SHA-256"}, keyMaterial, {name:"AES-GCM", length:256}, true, ["encrypt","decrypt"]);
  }
  async function encryptPrivateKey(privateKey,password){
    const exported = await crypto.subtle.exportKey("pkcs8", privateKey);
    const salt = crypto.getRandomValues(new Uint8Array(16));
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const aesKey = await deriveKeyFromPassword(password,salt);
    const encrypted = await crypto.subtle.encrypt({name:"AES-GCM", iv}, aesKey, exported);
    return { encrypted:new Uint8Array(encrypted), salt, iv };
  }
  async function decryptPrivateKey(encryptedObj,password){
    const aesKey = await deriveKeyFromPassword(password, encryptedObj.salt);
    const decrypted = await crypto.subtle.decrypt({name:"AES-GCM", iv:encryptedObj.iv}, aesKey, encryptedObj.encrypted);
    return await crypto.subtle.importKey("pkcs8", decrypted, {name:"RSA-OAEP", hash:"SHA-256"}, true, ["decrypt"]);
  }

  // ============================================================
  // MAIN LOGIC
  // ============================================================
  let keys;
  const userPassword = "myDemoPassword123!";

  async function setup(){
    const stored = localStorage.getItem("encryptedPrivateKey");
    const storedPub = localStorage.getItem("publicKey");

    if(stored && storedPub){
      try {
        const parsed = JSON.parse(stored);
        const privateKey = await decryptPrivateKey({
          encrypted:new Uint8Array(parsed.encrypted),
          salt:new Uint8Array(parsed.salt),
          iv:new Uint8Array(parsed.iv)
        }, userPassword);

        const publicKey = await importPublicKey(storedPub);

        keys = { privateKey, publicKey };
        console.log("Keys loaded successfully!");
      } catch(e){
        alert("Failed to decrypt stored keys. Clearing storage.");
        localStorage.clear();
        location.reload();
      }
    } else {
      keys = await generateRSAKeys();
      const encryptedKey = await encryptPrivateKey(keys.privateKey, userPassword);
      localStorage.setItem("encryptedPrivateKey", JSON.stringify({
        encrypted:Array.from(encryptedKey.encrypted),
        salt:Array.from(encryptedKey.salt),
        iv:Array.from(encryptedKey.iv)
      }));

      const pubExport = await exportKey(keys.publicKey);
      localStorage.setItem("publicKey", pubExport);

      console.log("New key pair generated and stored.");
    }
  }

  document.getElementById("run").addEventListener("click", async ()=>{
    const msg = document.getElementById("message").value;
    const encryptedPkg = await hybridEncrypt(msg, keys.publicKey);
    const decryptedMsg = await hybridDecrypt(encryptedPkg, keys.privateKey);

    document.getElementById("output").textContent =
      "Original: " + msg + "\n\n" +
      "Encrypted Package:\n" + JSON.stringify(encryptedPkg,null,2) + "\n\n" +
      "Decrypted: " + decryptedMsg;
  });

  setup();
  </script>
</body>
</html>
