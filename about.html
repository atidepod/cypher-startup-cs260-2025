<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Cypher Encryption Demo</title>
</head>
<body background="background.jpg" style="font-family:Arial; padding:2rem;">
    <table width="100%" bgcolor="#333" cellpadding="10">
    <tr>
      <td align="left"><font color="white"><b>Cypher</b></font></td>
      <td align="right">
        <a href="index.html"><font color="white">Home</font></a> |
        <a href="message.html"><font color="white">Messages</font></a> |
        
        <a href="https://github.com/atidepod/cypher-startup-cs260-2025"><font color="white">Github</font></a>
      </td>
    </tr>
  </table>
  <h1>Cypher Encryption Demo</h1>
  <p><font color="white">This is a quick demo of what goes on behind the scenes with this messaging software. A plaintext message is encrypted using 
    a One-Time-Pad style algorithem. A new random key is generated for each message, ensuring security. 
    The random key is also encrypted using a RSA Modulus cypher, and is packed with HMAC noise to ensure message integrety. 
    Type something into the message box to see the raw values that are sent to your friends. 
  </font></p>

  <!-- Message input -->
  <textarea id="message" rows="4" cols="50" placeholder="Type a message..."></textarea><br><br>
  <button id="run">Encrypt & Decrypt</button>
  <pre id="output"></pre>

  <hr/>

  <!-- Key management ____to be used later_____
  <h2>Public Key Management</h2>
  <button id="exportKey">Export Public Key</button><br><br>

  <textarea id="importKeyInput" rows="4" cols="50" placeholder="Paste a public key here..."></textarea><br>
  <button id="importKey">Import Public Key</button>
  <pre id="importResult"></pre>
-->
  <script>
  // ============================================================
  // ALPHABET MAPS
  // ============================================================
  const alphabetMap = {
    ...Object.fromEntries(Array.from({length:26}, (_, i) => [String.fromCharCode(97+i), i])),        // a-z
    ...Object.fromEntries(Array.from({length:26}, (_, i) => [String.fromCharCode(65+i), 26 + i])),   // A-Z
    ...Object.fromEntries(Array.from({length:10}, (_, i) => [String(i), 52 + i])),                   // 0-9
    " ": 62, ".": 63, ",": 64, "!": 65, "?": 66,
    "'": 67, "\"": 68, ":": 69, ";": 70, "-": 71,
    "(": 72, ")": 73
  };
  const reverseMap = Object.fromEntries(Object.entries(alphabetMap).map(([k,v]) => [v,k]));

  function textToNumbers(s){ return [...s].map(c=>alphabetMap[c]).filter(v=>v!==undefined); }
  function numbersToText(nums){ return nums.map(n => reverseMap[n]||"").join(""); }

  // ============================================================
  // OTP FUNCTIONS
  // ============================================================
  function generateOtp(length){
    const otp = new Uint8Array(length);
    crypto.getRandomValues(otp);
    return Array.from(otp, b => b % Object.keys(alphabetMap).length);
  }
  function otpEncrypt(numbers,key){
    const L = Object.keys(alphabetMap).length;
    return numbers.map((n,i)=> (n + key[i]) % L);
  }
  function otpDecrypt(numbers,key){
    const L = Object.keys(alphabetMap).length;
    return numbers.map((c,i)=> (c - key[i] + L) % L);
  }

  // ============================================================
  // RSA KEY MANAGEMENT
  // ============================================================
  async function generateRSAKeys(){
    return await crypto.subtle.generateKey(
      { name:"RSA-OAEP", modulusLength:2048, publicExponent:new Uint8Array([1,0,1]), hash:"SHA-256" },
      true,
      ["encrypt","decrypt"]
    );
  }
  async function exportKey(key){
    const exported = await crypto.subtle.exportKey("spki", key);
    return btoa(String.fromCharCode(...new Uint8Array(exported)));
  }
  async function importPublicKey(base64Key){
    const binary = Uint8Array.from(atob(base64Key), c=>c.charCodeAt(0));
    return await crypto.subtle.importKey("spki", binary.buffer, {name:"RSA-OAEP", hash:"SHA-256"}, true, ["encrypt"]);
  }

  // ============================================================
  // HMAC
  // ============================================================
  async function generateHmac(keyBytes,messageBytes){
    const cryptoKey = await crypto.subtle.importKey(
      "raw", new Uint8Array(keyBytes), {name:"HMAC", hash:"SHA-256"}, false, ["sign"]
    );
    const sig = await crypto.subtle.sign("HMAC", cryptoKey, new Uint8Array(messageBytes));
    return Array.from(new Uint8Array(sig)).map(b=>b.toString(16).padStart(2,"0")).join("");
  }

  // ============================================================
  // HYBRID ENCRYPT / DECRYPT
  // ============================================================
  async function hybridEncrypt(message, publicKey){
    const msgNumbers = textToNumbers(message);
    const otpKey = generateOtp(msgNumbers.length);
    const encryptedMessage = otpEncrypt(msgNumbers, otpKey);

    const encryptedOtpKey = await Promise.all(
      otpKey.map(async k => {
        const enc = await crypto.subtle.encrypt({name:"RSA-OAEP"}, publicKey, new Uint8Array([k]));
        return btoa(String.fromCharCode(...new Uint8Array(enc)));
      })
    );

    const mac = await generateHmac(otpKey, encryptedMessage);
    return { encrypted_message: encryptedMessage, encrypted_otp_key: encryptedOtpKey, hmac: mac };
  }

  async function hybridDecrypt(pkg, privateKey){
    const otpKey = await Promise.all(
      pkg.encrypted_otp_key.map(async encStr => {
        const binary = Uint8Array.from(atob(encStr), c=>c.charCodeAt(0));
        const dec = await crypto.subtle.decrypt({name:"RSA-OAEP"}, privateKey, binary.buffer);
        const arr = new Uint8Array(dec);
        return arr[arr.length - 1]; // last byte holds the key value
      })
    );

    const macCheck = await generateHmac(otpKey, pkg.encrypted_message);
    if(macCheck !== pkg.hmac) throw new Error("Message integrity check failed!");

    const decryptedNumbers = otpDecrypt(pkg.encrypted_message, otpKey);
    return numbersToText(decryptedNumbers);
  }

  // ============================================================
  // PASSWORD-PROTECTED PRIVATE KEY STORAGE
  // ============================================================
  async function deriveKeyFromPassword(password,salt){
    const enc = new TextEncoder();
    const keyMaterial = await crypto.subtle.importKey("raw", enc.encode(password), "PBKDF2", false, ["deriveKey"]);
    return crypto.subtle.deriveKey({name:"PBKDF2", salt, iterations:100000, hash:"SHA-256"}, keyMaterial, {name:"AES-GCM", length:256}, true, ["encrypt","decrypt"]);
  }
  async function encryptPrivateKey(privateKey,password){
    const exported = await crypto.subtle.exportKey("pkcs8", privateKey);
    const salt = crypto.getRandomValues(new Uint8Array(16));
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const aesKey = await deriveKeyFromPassword(password,salt);
    const encrypted = await crypto.subtle.encrypt({name:"AES-GCM", iv}, aesKey, exported);
    return { encrypted:new Uint8Array(encrypted), salt, iv };
  }
  async function decryptPrivateKey(encryptedObj,password){
    const aesKey = await deriveKeyFromPassword(password, encryptedObj.salt);
    const decrypted = await crypto.subtle.decrypt({name:"AES-GCM", iv:encryptedObj.iv}, aesKey, encryptedObj.encrypted);
    return await crypto.subtle.importKey("pkcs8", decrypted, {name:"RSA-OAEP", hash:"SHA-256"}, true, ["decrypt"]);
  }

  // ============================================================
  // MAIN LOGIC
  // ============================================================
  let keys;
  const userPassword = "myDemoPassword123!";

  async function setup(){
    const stored = localStorage.getItem("encryptedPrivateKey");
    const storedPub = localStorage.getItem("publicKey");

    if(stored && storedPub){
      try {
        const parsed = JSON.parse(stored);
        const privateKey = await decryptPrivateKey({
          encrypted:new Uint8Array(parsed.encrypted),
          salt:new Uint8Array(parsed.salt),
          iv:new Uint8Array(parsed.iv)
        }, userPassword);

        const publicKey = await importPublicKey(storedPub);

        keys = { privateKey, publicKey };
        console.log("Keys loaded successfully!");
      } catch(e){
        alert("Failed to decrypt stored keys. Clearing storage.");
        localStorage.clear();
        location.reload();
      }
    } else {
      keys = await generateRSAKeys();
      const encryptedKey = await encryptPrivateKey(keys.privateKey, userPassword);
      localStorage.setItem("encryptedPrivateKey", JSON.stringify({
        encrypted:Array.from(encryptedKey.encrypted),
        salt:Array.from(encryptedKey.salt),
        iv:Array.from(encryptedKey.iv)
      }));

      const pubExport = await exportKey(keys.publicKey);
      localStorage.setItem("publicKey", pubExport);

      console.log("New key pair generated and stored.");
    }
  }

  document.getElementById("run").addEventListener("click", async ()=>{
    const msg = document.getElementById("message").value;
    const encryptedPkg = await hybridEncrypt(msg, keys.publicKey);
    const decryptedMsg = await hybridDecrypt(encryptedPkg, keys.privateKey);

    document.getElementById("output").textContent =
      "Original: " + msg + "\n\n" +
      "Encrypted Package:\n" + JSON.stringify(encryptedPkg,null,2) + "\n\n" +
      "Decrypted: " + decryptedMsg;
  });

  setup();
  </script>

</body>
</html>
